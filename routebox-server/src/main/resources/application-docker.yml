spring:
  application:
    name: routebox-server

  # Docker Compose Profile
  docker:
    compose:
      # Set enabled to true to enable Spring Boot's automatic Docker Compose lifecycle management
      # When enabled, Spring Boot will start/stop the services defined in compose.yaml
      # lifecycle-management: none disables automatic lifecycle management
      # Use 'docker compose up -d' manually to start services when needed
      enabled: false
      file: compose.yaml
      lifecycle-management: none

  # Default datasource (H2) - Inherited from application.yml
  # Default JPA (H2) - Inherited from application.yml
  # Default H2 Console - Inherited from application.yml

  # VIRTUAL THREADS (Java 21+)
  # This is inherited from application.yml (enabled: true)
  # We MUST ensure it is not disabled by a profile.
  threads:
    virtual:
      enabled: true

  # KAFKA CONFIGURATION
  # All Kafka config (clusters, routing, factory)
  # is inherited from application.yml.
  # We MUST NOT define a default spring.kafka.bootstrap-servers
  # here, as it conflicts with the dynamic cluster map.

server:
  port: 8081

# Logging is inherited from application.yml

---
# Azure SQL Profile (when using docker-compose)
spring:
  config:
    activate:
      on-profile: azuresql

  datasource:
    url: jdbc:sqlserver://localhost:1433;databaseName=routebox;encrypt=true;trustServerCertificate=true
    driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
    username: sa
    password: ${DB_PASSWORD}

  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.SQLServerDialect
    show-sql: false

  h2:
    console:
      enabled: false # Disable H2 console when using SQL Server
